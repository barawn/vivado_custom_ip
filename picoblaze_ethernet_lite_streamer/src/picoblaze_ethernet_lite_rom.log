KCPSM6 Assembler log file for program 'C:\cygwin64\home\barawn\firmware\osu_ip\picoblaze_ethernet_lite_streamer\src\picoblaze_ethernet_lite_rom.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 24 Apr 2018
Assembly timestamp: 12:57:24

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 0CF hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 208
Memory locations available: 3888


Assembly listing

 Addr Code                               Instruction

 000                                     ; AXI4-Lite bridge.
 000                                     ; These are all in the constant-optimized space (0x00-0x0F)
 000                                     ; and can use OUTPUTK instructions. Nothing else can.
 000                                     CONSTANT axi_data_0, 08
 000                                     CONSTANT axi_data_1, 09
 000                                     CONSTANT axi_data_2, 0A
 000                                     CONSTANT axi_data_3, 0B
 000                                     CONSTANT axi_address_0, 0C
 000                                     CONSTANT axi_address_1, 0D
 000                                     CONSTANT axi_address_2, 0E
 000                                     CONSTANT axi_address_3, 0F
 000                                     CONSTANT axi_control, 00
 000                                     CONSTANT datamover_mm2s_status, 20
 000                                     CONSTANT datamover_mm2s_control, 21
 000                                     CONSTANT datamover_mm2s_btt_0, 22
 000                                     CONSTANT datamover_mm2s_btt_1, 23
 000                                     CONSTANT datamover_s2mm_status, 24
 000                                     CONSTANT datamover_s2mm_control, 25
 000                                     CONSTANT datamover_s2mm_brcvd_0, 26
 000                                     CONSTANT datamover_s2mm_brcvd_1, 27
 000                                     CONSTANT mac_0, 40
 000                                     CONSTANT mac_1, 41
 000                                     CONSTANT mac_2, 42
 000                                     CONSTANT mac_3, 43
 000                                     CONSTANT mac_4, 44
 000                                     CONSTANT mac_5, 45
 000                                     CONSTANT axie_MDIOADDR_L, E4
 000                                     CONSTANT axie_MDIOADDR_H, 07
 000                                     CONSTANT axie_MDIOWR_L, E8
 000                                     CONSTANT axie_MDIOWR_H, 07
 000                                     CONSTANT axie_MDIORD_L, EC
 000                                     CONSTANT axie_MDIORD_H, 07
 000                                     CONSTANT axie_MDIOCTRL_L, F0
 000                                     CONSTANT axie_MDIOCTRL_H, 07
 000                                     CONSTANT axie_TXPINGLEN_L, F4
 000                                     CONSTANT axie_TXPINGLEN_H, 07
 000                                     CONSTANT axie_GIE_L, F8
 000                                     CONSTANT axie_GIE_H, 07
 000                                     CONSTANT axie_TXPINGCTRL_L, FC
 000                                     CONSTANT axie_TXPINGCTRL_H, 07
 000                                     CONSTANT axie_TXPONGLEN_L, F4
 000                                     CONSTANT axie_TXPONGLEN_H, 0F
 000                                     CONSTANT axie_TXPONGCTRL_L, FC
 000                                     CONSTANT axie_TXPONGCTRL_H, 0F
 000                                     CONSTANT axie_RXPINGCTRL_L, FC
 000                                     CONSTANT axie_RXPINGCTRL_H, 17
 000                                     CONSTANT axie_RXPONGCTRL_L, FC
 000                                     CONSTANT axie_RXPONGCTRL_H, 1F
 000                                     CONSTANT axie_RXPING_TYPELEN_L, 0C
 000                                     CONSTANT axie_RXPING_TYPELEN_H, 10
 000                                     CONSTANT axie_RXPONG_TYPELEN_L, 0C
 000                                     CONSTANT axie_RXPONG_TYPELEN_H, 18
 000                                     NAMEREG s8, RX_current_buffer
 000                                     NAMEREG s9, TX_current_buffer
 000                                     NAMEREG sA, mm2s_status
 000                                     NAMEREG sB, s2mm_status
 000                                     ; AXI Accesses:
 000                                     ; OUTPUT addr_l, axi_base+axi_address
 000                                     ; OUTPUT addr_h, axi_address_1
 000                                     ; LOAD   sF,     01  (or 03 for write)
 000                                     ; OUTPUT sF,     axi_control
 000                                     ; jp1: INPUT  sF,     axi_control
 000                                     ; TEST sF, 08
 000                                     ; JUMP Z jp1
 000                                     ; data to write/read is at axi_data_0+[3:0]
 000                                     ;
 000                                     ; We don't make these functions because it's much faster not to.
 000                              reset: 
 000                                     ; The AXI EthernetLite is crap:
 000                                     ; the MAC address gets written BIG ENDIAN into the damn
 000                                     ; transmit buffer. So
 000                                     ; mac[5] at 0x00
 000                                     ; mac[4] at 0x01
 000                                     ; mac[3] at 0x02
 000                                     ; mac[2] at 0x03
 000                                     ; mac[1] at 0x04
 000                                     ; mac[0] at 0x05
 000                                     ;; Write mac[3:0] into address 0x0000
 000  2B00C                              OUTPUTK 00, C[axi_address_0]
 001  2B00D                              OUTPUTK 00, D[axi_address_1]
 002  09045                              INPUT s0, 45[mac_5]
 003  09144                              INPUT s1, 44[mac_4]
 004  09243                              INPUT s2, 43[mac_3]
 005  09342                              INPUT s3, 42[mac_2]
 006  2D008                              OUTPUT s0, 08[axi_data_0]
 007  2D109                              OUTPUT s1, 09[axi_data_1]
 008  2D20A                              OUTPUT s2, 0A[axi_data_2]
 009  2D30B                              OUTPUT s3, 0B[axi_data_3]
 00A  2B030                              OUTPUTK 03, 0[axi_control]
 00B                          reset_jp1: 
 00B  09F00                              INPUT sF, 00[axi_control]
 00C  0DF08                              TEST sF, 08
 00D  3200B                              JUMP Z, 00B[reset_jp1]
 00E                                     ;; Write mac[5:4] into address 0x0004
 00E  2B04C                              OUTPUTK 04, C[axi_address_0]
 00F  2B00D                              OUTPUTK 00, D[axi_address_1]
 010  09041                              INPUT s0, 41[mac_1]
 011  09140                              INPUT s1, 40[mac_0]
 012  2D008                              OUTPUT s0, 08[axi_data_0]
 013  2D109                              OUTPUT s1, 09[axi_data_1]
 014  2B00A                              OUTPUTK 00, A[axi_data_2]
 015  2B00B                              OUTPUTK 00, B[axi_data_3]
 016  2B030                              OUTPUTK 03, 0[axi_control]
 017                          reset_jp2: 
 017  09F00                              INPUT sF, 00[axi_control]
 018  0DF08                              TEST sF, 08
 019  32017                              JUMP Z, 017[reset_jp2]
 01A                                     ;; Now write 0x03 to address 0x7FC (TXPINGCTRL)
 01A  2BFCC                              OUTPUTK FC[axie_TXPINGCTRL_L], C[axi_address_0]
 01B  2B07D                              OUTPUTK 07[axie_TXPINGCTRL_H], D[axi_address_1]
 01C  2B038                              OUTPUTK 03, 8[axi_data_0]
 01D  2B009                              OUTPUTK 00, 9[axi_data_1]
 01E  2B00A                              OUTPUTK 00, A[axi_data_2]
 01F  2B00B                              OUTPUTK 00, B[axi_data_3]
 020  2B030                              OUTPUTK 03, 0[axi_control]
 021                          reset_jp3: 
 021  09F00                              INPUT sF, 00[axi_control]
 022  0DF08                              TEST sF, 08
 023  32021                              JUMP Z, 021[reset_jp3]
 024                                     ; Now read from 0x7FC and check status/program bits.
 024                          reset_jp4: 
 024  2B010                              OUTPUTK 01, 0[axi_control]
 025                          reset_jp5: 
 025  09F00                              INPUT sF, 00[axi_control]
 026  0DF08                              TEST sF, 08
 027  32025                              JUMP Z, 025[reset_jp5]
 028                                     ; Check status/program bits (bits 0 & 1)
 028  09F08                              INPUT sF, 08[axi_data_0]
 029  03F03                              AND sF, 03
 02A  36024                              JUMP NZ, 024[reset_jp4]
 02B                                     ;; OK, MAC address programmed.
 02B                                     ; Clear buffer status/MM2S status.
 02B  01800                              LOAD s8[RX_current_buffer], 00
 02C  01A00                              LOAD sA[mm2s_status], 00
 02D  01900                              LOAD s9[TX_current_buffer], 00
 02E  01B00                              LOAD sB[s2mm_status], 00
 02F                               main: 
 02F                                     ;; Main loop
 02F                                     ;; 1: Check RX buffer.
 02F  2004D                              CALL 04D[check_RX_buffer]
 030                                     ;; 2: Check TX buffers.
 030  20034                              CALL 034[check_TX_buffer]
 031                                     ;; 3: Check MM2S Status.
 031  20093                              CALL 093[check_MM2S_status]
 032                                     ;; 4: Check S2MM Status.
 032  200AB                              CALL 0AB[check_S2MM_status]
 033  2202F                              JUMP 02F[main]
 034                                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 034                                     ;; Check for an outgoing buffer.
 034                                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 034                    check_TX_buffer: 
 034                                     ; Check to see if a transaction is pending.
 034  09025                              INPUT s0, 25[datamover_s2mm_control]
 035  0D020                              TEST s0, 20
 036                                     ; If not set, do nothing.
 036  31000                              RETURN Z
 037                                     ; It's set. Are both buffers pending? (not likely, but... whatever)
 037  1DB03                              COMPARE sB[s2mm_status], 03
 038  31000                              RETURN Z
 039                                     ; Nope, so we need to do something.
 039                                     ; Read from either 0x07FC or 0x0FFC.
 039                                     ; Current buffer is either 0x00 or 0x08 (it's the high byte base address). Copy it.
 039  00190                              LOAD s1, s9[TX_current_buffer]
 03A  11107                              ADD s1, 07
 03B  2BFCC                              OUTPUTK FC, C[axi_address_0]
 03C  2D10D                              OUTPUT s1, 0D[axi_address_1]
 03D  2B010                              OUTPUTK 01, 0[axi_control]
 03E                check_TX_buffer_jp1: 
 03E  09F00                              INPUT sF, 00[axi_control]
 03F  0DF08                              TEST sF, 08
 040  3203E                              JUMP Z, 03E[check_TX_buffer_jp1]
 041  09F08                              INPUT sF, 08[axi_data_0]
 042                                     ; Is the busy bit set? (note that *we* set this when an S2MM transaction completes)
 042  0DF01                              TEST sF, 01
 043                                     ; If not, poll it. It'll get cleared when that buffer gets sent out.
 043  39000                              RETURN C
 044                                     ; It's not set - so it's available.
 044                                     ; Execute a DataMover command to stream data into the buffer.
 044                                     ; So we need to set buffer (bit 3) and start (bit 0).
 044                                     ; s1 is either 07 or 0F, and we want it to be 01 or 09.
 044  03109                              AND s1, 09
 045  2D125                              OUTPUT s1, 25[datamover_s2mm_control]
 046                                     ; Now we need to set the right bit in s2mm_buffer_status.
 046  0D908                              TEST s9[TX_current_buffer], 08
 047  3604A                              JUMP NZ, 04A[check_TX_buffer_jp2]
 048  05B01                              OR sB[s2mm_status], 01
 049  2204B                              JUMP 04B[check_TX_buffer_jp3]
 04A                check_TX_buffer_jp2: 
 04A  05B02                              OR sB[s2mm_status], 02
 04B                check_TX_buffer_jp3: 
 04B  07908                              XOR s9[TX_current_buffer], 08
 04C  25000                              RETURN 
 04D                                     ; Lifecycle of received buffers:
 04D                                     ; 3x quick buffers:
 04D                                     ; BEGINNING: RX_current_buffer=0, mm2s_status=0
 04D                                     ; PING BUFFER FILLS, COMMAND ISSUED: RX_current_buffer=8, mm2s_status=1
 04D                                     ; PONG BUFFER FILLS, COMMAND ISSUED: RX_current_buffer=0, mm2s_status=3
 04D                                     ; PING COMMAND COMPLETION DONE: RX_current_buffer=0, mm2s_status=2
 04D                                     ; PING BUFFER FILLS AGAIN, COMMAND ISSUED: RX_current_buffer=8, mm2s_status=3
 04D                                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 04D                                     ;; Check for an incoming buffer.
 04D                                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 04D                    check_RX_buffer: 
 04D                                     ; Check to see if 2x MM2S commands are pending.
 04D  1DA03                              COMPARE sA[mm2s_status], 03
 04E                                     ; If so, bail out. Nothing else to do.
 04E  31000                              RETURN Z
 04F                                     ; Need to read from 0x17FC or 0x1FFC.
 04F                                     ; Current buffer is either 0x00 or 0x08. Copy it.
 04F  00180                              LOAD s1, s8[RX_current_buffer]
 050                                     ; Add 0x17 (to make 0x17 or 0x1F)
 050  11117                              ADD s1, 17
 051  2BFCC                              OUTPUTK FC, C[axi_address_0]
 052  2D10D                              OUTPUT s1, 0D[axi_address_1]
 053  2B010                              OUTPUTK 01, 0[axi_control]
 054                check_RX_buffer_jp1: 
 054  09F00                              INPUT sF, 00[axi_control]
 055  0DF08                              TEST sF, 08
 056  32054                              JUMP Z, 054[check_RX_buffer_jp1]
 057  09F08                              INPUT sF, 08[axi_data_0]
 058                                     ; Is the status bit set?
 058  0DF01                              TEST sF, 01
 059                                     ; No, so we're done.
 059  31000                              RETURN Z
 05A                                     ; OK, so now we actually have something. Jump back to base + 0x0C.
 05A                                     ; This is after the source/dest addresses (12 bytes = 3 ints)
 05A                                     ; s1 is either 0x17 or 0x1F. Drop the low 3 bits.
 05A  03118                              AND s1, 18
 05B  2B0CC                              OUTPUTK 0C, C[axi_address_0]
 05C  2D10D                              OUTPUT s1, 0D[axi_address_1]
 05D  2B010                              OUTPUTK 01, 0[axi_control]
 05E                check_RX_buffer_jp2: 
 05E  09F00                              INPUT sF, 00[axi_control]
 05F  0DF08                              TEST sF, 08
 060  3205E                              JUMP Z, 05E[check_RX_buffer_jp2]
 061                                     ; Now check ethertype. This is in the low byte, since it's
 061                                     ; the 13th byte received (e.g. base + 0x0C)
 061                                     ; Needs to be 0x08.
 061  09208                              INPUT s2, 08[axi_data_0]
 062  1D208                              COMPARE s2, 08
 063  36085                              JUMP NZ, 085[dump_RX_buffer]
 064                                     ; Check the next byte. Needs to be 0x06 (ARP) or 0x00 (IPv4)
 064  09209                              INPUT s2, 09[axi_data_1]
 065  1D206                              COMPARE s2, 06
 066  32078                              JUMP Z, 078[check_RX_buffer_ARP]
 067  1D200                              COMPARE s2, 00
 068  36085                              JUMP NZ, 085[dump_RX_buffer]
 069                 check_RX_buffer_IP: 
 069                                     ; it's an IP packet. Add 4 to the address (0x10).
 069                                     ; axi_address_1 doesn't need to change.
 069  2B10C                              OUTPUTK 10, C[axi_address_0]
 06A  2B010                              OUTPUTK 01, 0[axi_control]
 06B             check_RX_buffer_IP_jp1: 
 06B  09F00                              INPUT sF, 00[axi_control]
 06C  0DF08                              TEST sF, 08
 06D  3206B                              JUMP Z, 06B[check_RX_buffer_IP_jp1]
 06E                                     ; We're now at base + 0x10. Grab the next two bytes.
 06E                                     ; First is the most-significant byte (big-endian!)
 06E  09308                              INPUT s3, 08[axi_data_0]
 06F                                     ; Next is the least-significant byte (big-endian!)
 06F  09209                              INPUT s2, 09[axi_data_1]
 070                                     ; Add 18. (source+dest+typelen+FCS)
 070  11212                              ADD s2, 12
 071  13300                              ADDCY s3, 00
 072  1D240                              COMPARE s2, 40
 073  1F300                              COMPARECY s3, 00
 074  3A076                              JUMP C, 076[check_RX_buffer_IP_jp2]
 075  2207A                              JUMP 07A[RX_output_mm2s_command]
 076             check_RX_buffer_IP_jp2: 
 076  01240                              LOAD s2, 40
 077  2207A                              JUMP 07A[RX_output_mm2s_command]
 078                check_RX_buffer_ARP: 
 078  01240                              LOAD s2, 40
 079  01300                              LOAD s3, 00
 07A                                     ; Output the MM2S command.
 07A                                     ; Bytes to transfer is in s2/s3.
 07A             RX_output_mm2s_command: 
 07A                                     ; s1 is from our last AXI address, which was either 0x1810 or 0x1010 (so s1=0x18 or 0x10).
 07A                                     ; So we just set the bottom bit. Top bit is unimportant (not used).
 07A  05101                              OR s1, 01
 07B  2D222                              OUTPUT s2, 22[datamover_mm2s_btt_0]
 07C  2D323                              OUTPUT s3, 23[datamover_mm2s_btt_1]
 07D  2D121                              OUTPUT s1, 21[datamover_mm2s_control]
 07E                                     ; Now set the appropriate bit in mm2s_status
 07E  0D808                              TEST s8[RX_current_buffer], 08
 07F  36082                              JUMP NZ, 082[RX_output_mm2s_command_jp1]
 080  05A01                              OR sA[mm2s_status], 01
 081  22083                              JUMP 083[RX_output_mm2s_command_jp2]
 082         RX_output_mm2s_command_jp1: 
 082  05A02                              OR sA[mm2s_status], 02
 083         RX_output_mm2s_command_jp2: 
 083  07808                              XOR s8[RX_current_buffer], 08
 084  25000                              RETURN 
 085                                     ; Abandon the current buffer (not IP or ICMP)
 085                     dump_RX_buffer: 
 085  00180                              LOAD s1, s8[RX_current_buffer]
 086  11117                              ADD s1, 17
 087  2BFCC                              OUTPUTK FC, C[axi_address_0]
 088  2D10D                              OUTPUT s1, 0D[axi_address_1]
 089  2B008                              OUTPUTK 00, 8[axi_data_0]
 08A  2B009                              OUTPUTK 00, 9[axi_data_1]
 08B  2B00A                              OUTPUTK 00, A[axi_data_2]
 08C  2B00B                              OUTPUTK 00, B[axi_data_3]
 08D  2B030                              OUTPUTK 03, 0[axi_control]
 08E                 dump_RX_buffer_jp1: 
 08E  09F00                              INPUT sF, 00[axi_control]
 08F  0DF08                              TEST sF, 08
 090  3208E                              JUMP Z, 08E[dump_RX_buffer_jp1]
 091                                     ; Still need to toggle the buffer.
 091  07808                              XOR s8[RX_current_buffer], 08
 092  25000                              RETURN 
 093                                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 093                                     ;; Check for completion of incoming buffer.
 093                                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 093                  check_MM2S_status: 
 093  09F21                              INPUT sF, 21[datamover_mm2s_control]
 094                                     ; is the done bit set?
 094  0DF04                              TEST sF, 04
 095  31000                              RETURN Z
 096                                     ; Yes, it is. Now check the received status byte.
 096  09F20                              INPUT sF, 20[datamover_mm2s_status]
 097  0DF08                              TEST sF, 08
 098                                     ; Is this the pong buffer?
 098  3609B                              JUMP NZ, 09B[check_mm2s_status_jp1]
 099                                     ; The 'buffer' bit is not set, so this is the ping buffer.
 099                                     ; Clear mm2s_status bit 1.
 099  03A02                              AND sA[mm2s_status], 02
 09A  2209C                              JUMP 09C[check_mm2s_status_jp2]
 09B              check_mm2s_status_jp1: 
 09B                                     ; The 'buffer' bit is set, so this is the pong buffer.
 09B                                     ; Clear mm2s_status bit 0.
 09B  03A01                              AND sA[mm2s_status], 01
 09C              check_mm2s_status_jp2: 
 09C                                     ; sF is now 00 or 08.
 09C                                     ; We want to write 0x0 to 0x17FC or 0x1FFC (RX ping or pong control)
 09C                                     ; So copy sF, add 17 to it, and combine it with FC.
 09C  001F0                              LOAD s1, sF
 09D  11117                              ADD s1, 17
 09E  2BFCC                              OUTPUTK FC, C[axi_address_0]
 09F  2D10D                              OUTPUT s1, 0D[axi_address_1]
 0A0  2B008                              OUTPUTK 00, 8[axi_data_0]
 0A1  2B009                              OUTPUTK 00, 9[axi_data_1]
 0A2  2B00A                              OUTPUTK 00, A[axi_data_2]
 0A3  2B00B                              OUTPUTK 00, B[axi_data_3]
 0A4  2B030                              OUTPUTK 03, 0[axi_control]
 0A5              check_mm2s_status_jp3: 
 0A5  09F00                              INPUT sF, 00[axi_control]
 0A6  0DF08                              TEST sF, 08
 0A7  320A5                              JUMP Z, 0A5[check_mm2s_status_jp3]
 0A8  01F04                              LOAD sF, 04
 0A9                                     ; Clear the done bit to accept the next status word.
 0A9  2DF21                              OUTPUT sF, 21[datamover_mm2s_control]
 0AA                                     ; Done.
 0AA  25000                              RETURN 
 0AB                                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 0AB                                     ;; Check for completion of outgoing buffer.
 0AB                                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 0AB                  check_S2MM_status: 
 0AB  09F25                              INPUT sF, 25[datamover_s2mm_control]
 0AC  0DF04                              TEST sF, 04
 0AD  31000                              RETURN Z
 0AE                                     ; Yes, it is. Now check the received status byte.
 0AE  09F24                              INPUT sF, 24[datamover_s2mm_status]
 0AF  0DF08                              TEST sF, 08
 0B0  360B3                              JUMP NZ, 0B3[check_s2mm_status_jp1]
 0B1  03B02                              AND sB[s2mm_status], 02
 0B2  220B4                              JUMP 0B4[check_s2mm_status_jp2]
 0B3              check_s2mm_status_jp1: 
 0B3  03B01                              AND sB[s2mm_status], 01
 0B4              check_s2mm_status_jp2: 
 0B4  09226                              INPUT s2, 26[datamover_s2mm_brcvd_0]
 0B5  09327                              INPUT s3, 27[datamover_s2mm_brcvd_1]
 0B6  03F08                              AND sF, 08
 0B7                                     ; sF is now 00 or 08.
 0B7                                     ; We want to write (s3,s2) to 0x07F4 or 0x0FF4.
 0B7  001F0                              LOAD s1, sF
 0B8  11107                              ADD s1, 07
 0B9  2BF4C                              OUTPUTK F4, C[axi_address_0]
 0BA  2D10D                              OUTPUT s1, 0D[axi_address_1]
 0BB  2D208                              OUTPUT s2, 08[axi_data_0]
 0BC  2D309                              OUTPUT s3, 09[axi_data_1]
 0BD  2B00A                              OUTPUTK 00, A[axi_data_2]
 0BE  2B00B                              OUTPUTK 00, B[axi_data_3]
 0BF  2B030                              OUTPUTK 03, 0[axi_control]
 0C0              check_s2mm_status_jp3: 
 0C0  09F00                              INPUT sF, 00[axi_control]
 0C1  0DF08                              TEST sF, 08
 0C2  320C0                              JUMP Z, 0C0[check_s2mm_status_jp3]
 0C3                                     ; Now write 01 to transmit control. Move forward 2 registers. (0x07FC/0x0FFC)
 0C3  2BFCC                              OUTPUTK FC, C[axi_address_0]
 0C4  2D10D                              OUTPUT s1, 0D[axi_address_1]
 0C5  2B018                              OUTPUTK 01, 8[axi_data_0]
 0C6  2B009                              OUTPUTK 00, 9[axi_data_1]
 0C7  2B00A                              OUTPUTK 00, A[axi_data_2]
 0C8  2B00B                              OUTPUTK 00, B[axi_data_3]
 0C9  2B030                              OUTPUTK 03, 0[axi_control]
 0CA              check_s2mm_status_jp4: 
 0CA  09F00                              INPUT sF, 00[axi_control]
 0CB  0DF08                              TEST sF, 08
 0CC  320CA                              JUMP Z, 0CA[check_s2mm_status_jp4]
 0CD                                     ; Now clear the DONE bit to accept next.
 0CD  01F04                              LOAD sF, 04
 0CE  2DF25                              OUTPUT sF, 25[datamover_s2mm_control]
 0CF  25000                              RETURN 


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\cygwin64\home\barawn\firmware\osu_ip\picoblaze_ethernet_lite_streamer\src\picoblaze_ethernet_lite_rom.psm



List of defined constants

 CONSTANT name          Value        Source PSM File

 timestamp_hours        12'd         
 timestamp_minutes      57'd         
 timestamp_seconds      24'd         
 datestamp_year         18'd         
 datestamp_month        4'd          
 datestamp_day          24'd         
 NUL                    00           
 BEL                    07           
 BS                     08           
 HT                     09           
 LF                     0A           
 VT                     0B           
 CR                     0D           
 ESC                    1B           
 DEL                    7F           
 DCS                    90           
 ST                     9C           
 axi_data_0             08           picoblaze_ethernet_lite_rom.psm
 axi_data_1             09           picoblaze_ethernet_lite_rom.psm
 axi_data_2             0A           picoblaze_ethernet_lite_rom.psm
 axi_data_3             0B           picoblaze_ethernet_lite_rom.psm
 axi_address_0          0C           picoblaze_ethernet_lite_rom.psm
 axi_address_1          0D           picoblaze_ethernet_lite_rom.psm
 axi_address_2          0E           picoblaze_ethernet_lite_rom.psm
 axi_address_3          0F           picoblaze_ethernet_lite_rom.psm
 axi_control            00           picoblaze_ethernet_lite_rom.psm
 datamover_mm2s_status  20           picoblaze_ethernet_lite_rom.psm
 datamover_mm2s_control 21           picoblaze_ethernet_lite_rom.psm
 datamover_mm2s_btt_0   22           picoblaze_ethernet_lite_rom.psm
 datamover_mm2s_btt_1   23           picoblaze_ethernet_lite_rom.psm
 datamover_s2mm_status  24           picoblaze_ethernet_lite_rom.psm
 datamover_s2mm_control 25           picoblaze_ethernet_lite_rom.psm
 datamover_s2mm_brcvd_0 26           picoblaze_ethernet_lite_rom.psm
 datamover_s2mm_brcvd_1 27           picoblaze_ethernet_lite_rom.psm
 mac_0                  40           picoblaze_ethernet_lite_rom.psm
 mac_1                  41           picoblaze_ethernet_lite_rom.psm
 mac_2                  42           picoblaze_ethernet_lite_rom.psm
 mac_3                  43           picoblaze_ethernet_lite_rom.psm
 mac_4                  44           picoblaze_ethernet_lite_rom.psm
 mac_5                  45           picoblaze_ethernet_lite_rom.psm
 axie_MDIOADDR_L        E4           picoblaze_ethernet_lite_rom.psm
 axie_MDIOADDR_H        07           picoblaze_ethernet_lite_rom.psm
 axie_MDIOWR_L          E8           picoblaze_ethernet_lite_rom.psm
 axie_MDIOWR_H          07           picoblaze_ethernet_lite_rom.psm
 axie_MDIORD_L          EC           picoblaze_ethernet_lite_rom.psm
 axie_MDIORD_H          07           picoblaze_ethernet_lite_rom.psm
 axie_MDIOCTRL_L        F0           picoblaze_ethernet_lite_rom.psm
 axie_MDIOCTRL_H        07           picoblaze_ethernet_lite_rom.psm
 axie_TXPINGLEN_L       F4           picoblaze_ethernet_lite_rom.psm
 axie_TXPINGLEN_H       07           picoblaze_ethernet_lite_rom.psm
 axie_GIE_L             F8           picoblaze_ethernet_lite_rom.psm
 axie_GIE_H             07           picoblaze_ethernet_lite_rom.psm
 axie_TXPINGCTRL_L      FC           picoblaze_ethernet_lite_rom.psm
 axie_TXPINGCTRL_H      07           picoblaze_ethernet_lite_rom.psm
 axie_TXPONGLEN_L       F4           picoblaze_ethernet_lite_rom.psm
 axie_TXPONGLEN_H       0F           picoblaze_ethernet_lite_rom.psm
 axie_TXPONGCTRL_L      FC           picoblaze_ethernet_lite_rom.psm
 axie_TXPONGCTRL_H      0F           picoblaze_ethernet_lite_rom.psm
 axie_RXPINGCTRL_L      FC           picoblaze_ethernet_lite_rom.psm
 axie_RXPINGCTRL_H      17           picoblaze_ethernet_lite_rom.psm
 axie_RXPONGCTRL_L      FC           picoblaze_ethernet_lite_rom.psm
 axie_RXPONGCTRL_H      1F           picoblaze_ethernet_lite_rom.psm
 axie_RXPING_TYPELEN_L  0C           picoblaze_ethernet_lite_rom.psm
 axie_RXPING_TYPELEN_H  10           picoblaze_ethernet_lite_rom.psm
 axie_RXPONG_TYPELEN_L  0C           picoblaze_ethernet_lite_rom.psm
 axie_RXPONG_TYPELEN_H  18           picoblaze_ethernet_lite_rom.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "24 Apr 2018"  
 timestamp$        "12:57:24"     



List of line labels

   Label                        Addr  Source PSM File

 * reset                        000   picoblaze_ethernet_lite_rom.psm
   reset_jp1                    00B   picoblaze_ethernet_lite_rom.psm
   reset_jp2                    017   picoblaze_ethernet_lite_rom.psm
   reset_jp3                    021   picoblaze_ethernet_lite_rom.psm
   reset_jp4                    024   picoblaze_ethernet_lite_rom.psm
   reset_jp5                    025   picoblaze_ethernet_lite_rom.psm
   main                         02F   picoblaze_ethernet_lite_rom.psm
   check_TX_buffer              034   picoblaze_ethernet_lite_rom.psm
   check_TX_buffer_jp1          03E   picoblaze_ethernet_lite_rom.psm
   check_TX_buffer_jp2          04A   picoblaze_ethernet_lite_rom.psm
   check_TX_buffer_jp3          04B   picoblaze_ethernet_lite_rom.psm
   check_RX_buffer              04D   picoblaze_ethernet_lite_rom.psm
   check_RX_buffer_jp1          054   picoblaze_ethernet_lite_rom.psm
   check_RX_buffer_jp2          05E   picoblaze_ethernet_lite_rom.psm
 * check_RX_buffer_IP           069   picoblaze_ethernet_lite_rom.psm
   check_RX_buffer_IP_jp1       06B   picoblaze_ethernet_lite_rom.psm
   check_RX_buffer_IP_jp2       076   picoblaze_ethernet_lite_rom.psm
   check_RX_buffer_ARP          078   picoblaze_ethernet_lite_rom.psm
   RX_output_mm2s_command       07A   picoblaze_ethernet_lite_rom.psm
   RX_output_mm2s_command_jp1   082   picoblaze_ethernet_lite_rom.psm
   RX_output_mm2s_command_jp2   083   picoblaze_ethernet_lite_rom.psm
   dump_RX_buffer               085   picoblaze_ethernet_lite_rom.psm
   dump_RX_buffer_jp1           08E   picoblaze_ethernet_lite_rom.psm
   check_MM2S_status            093   picoblaze_ethernet_lite_rom.psm
   check_mm2s_status_jp1        09B   picoblaze_ethernet_lite_rom.psm
   check_mm2s_status_jp2        09C   picoblaze_ethernet_lite_rom.psm
   check_mm2s_status_jp3        0A5   picoblaze_ethernet_lite_rom.psm
   check_S2MM_status            0AB   picoblaze_ethernet_lite_rom.psm
   check_s2mm_status_jp1        0B3   picoblaze_ethernet_lite_rom.psm
   check_s2mm_status_jp2        0B4   picoblaze_ethernet_lite_rom.psm
   check_s2mm_status_jp3        0C0   picoblaze_ethernet_lite_rom.psm
   check_s2mm_status_jp4        0CA   picoblaze_ethernet_lite_rom.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             14
 STAR              -

 AND               8
 OR                5
 XOR               3

 ADD               6
 ADDCY             1
 SUB               -
 SUBCY             -

 TEST             21
 TESTCY            -
 COMPARE           6
 COMPARECY         1

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               -
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            32
 OUTPUT           21
 OUTPUTK          46

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             28
 JUMP@             -
 CALL              4
 CALL@             -
 RETURN           12
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
